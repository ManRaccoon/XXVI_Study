## 📍문제 탐색하기

1. 첫째줄에 공백을 기준으로 행개수 n, 열개수 m이 주어짐.
2. 둘째줄부터 n개의 줄에 행렬 a의 원소 m개
3. 이어서 n개의 줄에 행렬 b의 원소 m개
4. 출력 - n개의 줄에 행렬 a와 b를 더한 행렬 출력

**시간복잡도**

1. ~~입력 O(1) + O(1) = O(1)~~
    - `input().split()` → **O(1)** (공백으로 구분된 두 개의 숫자 입력)
    - `map(int, ...)` → **O(1)**⇒ **총 O(1)**
2. ~~원소 m개 입력 O(1) + n개의 줄O(n) = O(n)~~
    - `input().split()` → 한 줄에 대해 **O(m)**
    - `map(int, ...)` 변환 → **O(m)**
    - `list()` 변환 → **O(m)**
    - `append(nums)` → **O(1)** (리스트 추가)
    
    각 행렬의 행(row) 수만큼 반복되므로, **총 O(n × m)**.
    
3. 2와 같음 = ~~O(n)~~ **O(n × m)**.
4. n개의 줄에 출력 = O(n)
    - **이중 for문**을 사용하여 `n × m` 번 실행.
    - 각 연산(`a[i][j] + b[i][j]`)은 **O(1)**.
    - `print()` 출력도 **O(1)** (고정된 개수 출력).
    
    ⇒ **총 O(n × m)**.
    

**🔹 최종 시간 복잡도**

각 단계의 시간 복잡도를 정리하면:

1. `m, n` 입력: **O(1)**
2. 행렬 `a` 입력: **O(n × m)**
3. 행렬 `b` 입력: **O(n × m)**
4. 행렬 덧셈 및 출력: **O(n × m)**

**전체 시간 복잡도는:**

$$
O(1)+O(n×m)+O(n×m)+O(n×m)=O(n×m)
$$

## 📍문제 설계하기

1. m,n 입력받기
2. 행렬 a,b 리스트 초기화
3. n번 반복 - 한 줄 m개의 원소 리스트 입력받고 a 리스트에 추가
4. n번 반복 - 한줄 m개의 원소 리스트 입력받고 b 리스트에 추가
5. n번 반복문 안에 m번 반복으로 리스트 인덱싱 - a,b 원소 인덱스 대응하는것끼리 더해서 같은줄 끼리는 end=” ”으로 줄바꿈 없이 출력

## 📍시도 회차 수정 사항 (Optional)

1. 처음 n, m을 입력받을 때 m,n을 바꿔서 입력받음…….



## 🥕 배운것

**시간복잡도**

1. 정수 N,M을 입력받기 → O(1)
2. 2차원 배열을 입력받기 → O(N*M)
3. 행렬의 덧셈을 구하고 출력하기 → O(N*M)
    - 2차원 배열안의 모든 원소를 한번씩 탐색합니다.

따라서 최종 시간복잡도는 O(N*M)입니다.

N과 M은 최대 100으로, 최대 연산개수는 약 10,000개로 시간 제한(1초)안에 풀이가 가능한 연산 개수 입니다.
