## 📍문제 탐색하기

- 입력
    - 첫째 줄: 숫자 카드 개수 `N` (1 ≤ N ≤ 500,000)
    - 둘째 줄: 상근이가 가지고 있는 숫자 카드에 적힌 정수들 (`10,000,000 ≤ 정수 ≤ 10,000,000`)
    - 셋째 줄: 확인할 숫자 개수 `M` (1 ≤ M ≤ 500,000)
    - 넷째 줄: 확인할 숫자들
- 문제
    - 상근이가 숫자 카드를 갖고 있는지 여부를 확인하여,
    - 각 숫자에 대해 가지고 있으면 1, 없으면 0을 공백으로 구분하여 출력하라.

---

## 📍문제 설계하기

> N, M이 최대 50만이므로 O(NM)의 완전탐색은 시간 초과
> 
> 
> → 빠른 탐색이 가능한 구조 필요 → 이진 탐색 or set 사용
> 

### 방법 1: 이진 탐색

1. 상근이 카드 리스트를 정렬
2. 확인 대상 숫자마다 이진 탐색 수행 → 시간복잡도: O(N log N + M log N)

### 방법 2: `set` 사용 (더 간단하고 빠름)

1. 상근이 카드들을 `set`에 저장 → 평균 탐색 시간 O(1)
2. 각 숫자가 `set`에 있는지 확인하여 출력

→ 두 방법 모두 통과 가능하지만 `set`이 더 간결

---

## 📍시도 회차 수정 사항 (Optional)

- 초기에는 리스트에 대해 `in` 사용 → 시간 초과 발생
- 이후 `set` 또는 `bisect`로 개선하여 시간 통과

---

## 🥕 배운 것

- 입력이 많고 탐색이 많은 문제에서는 탐색 속도가 관건
- `set` 자료형은 평균 O(1)의 탐색 시간을 보장하여 대용량 탐색에 매우 유리
- 문제 조건에서 수의 범위가 넓을 때는 배열 인덱스로 매핑하는 방식보다 set/dict가 유리
