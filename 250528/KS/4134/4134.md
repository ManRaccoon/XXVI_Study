📍문제 탐색하기
입력

첫째 줄: 테스트 케이스의 수 T (1 ≤ T ≤ 1,000)

이후 T개의 줄: 각각 하나의 정수 n (0 ≤ n ≤ 4,294,967,295)

문제

각 테스트 케이스마다 n 이상인 수 중에서 가장 작은 소수를 출력하라

📍문제 설계하기
입력 수가 매우 크기 때문에 단순한 소수 판별 방식(에라토스테네스)은 불가능
→ 매 테스트 케이스마다 is_prime을 통해 하나씩 검사

n 이상에서 시작하여 소수를 찾을 때까지 1씩 증가

소수 판별은 sqrt(n)까지 나눠보는 방식으로 진행

입력이 0 또는 1일 경우, 가장 가까운 소수는 2

시간복잡도는 테스트케이스당 평균 O(√n), 최대 1,000번이므로 적절히 최적화하면 통과 가능

📍시도 회차 수정 사항 (Optional)
없었음. 소수 판별 최적화(√n까지 검사)만 해도 충분히 통과 가능

🥕 배운 것
소수 판별 시 2와 홀수만 검사하면 시간을 크게 줄일 수 있음

math.isqrt(n)은 큰 수에서도 sqrt(n)을 정확하게 정수로 반환해 효율적

문제에서 최대 2^32 범위까지 커질 수 있으므로, 에라토스테네스 대신 직접 소수 판별 최적화가 필요

